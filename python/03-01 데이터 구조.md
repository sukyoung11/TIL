

# 03-01 데이터 구조



## 문자열

immutable 하다 - 중간 바꾸기 불가능

### 값의 위치 반환

`s.find(x)`  x의 첫번째 위치 반환, 없으면 -1반환

첫번째 위치가 아니라 다 알고 싶으면 반복문 + 삭제 이용

`s.index(x)` 없으면 오류발생

### 검증 메소드

`.istitle()`  공백 후의 문자가 대문자로 시작하는지

### 변경 메소드

`.replace(old,new,(count))`count를 지정하면 해당 개수만큼 시행

`.strip()`, `.lstrip()`, `.rstrip()` 문자열을 지정하지 않으면 공백 제거

`.swapcase()` 대문자>소문자, 소문자>대문자

`.split(sep, maxsplit)` sep이 none이거나 지정되지 않으면 공백문자 기준으로 나눔

​                                                 maxsplit 으로는 split을 몇 번 할지 지정 가능

`' '.join()`



  ## List

mutable

`.append()`

`.insert(i,x)` 정해진 위치 i에 값을 추가함

`.remove()` 리스트에서 값이 x인것 삭제, 없으면 error

`.pop(i)` i 위치에 있는 값을 삭제하고 반환, 지정하지 않으면 마지막 값 삭제, 반환

`.extend()` 

`.index()`

`.reverse()` 순서를 반대로 뒤집음, 원본 변경  ` !=reversed(x)`  내장 함수, 원본 변경 X

`.sort()` 정렬, 원본 변경 `!=sorted(x)` 내장 함수, 원본 변경 X

`clear()` 모든 값 삭제

`.count(x)` 원하는 값의 개수 반환



## Tuple

immutable



## Set

순서 없음, 중복 허용 안됨

`.add(x)` 

`.update(x,y,z)`

`.remove(x)`

`.discatd(x)` x없어도 error 발생하지 않음

`.pop()` **임의의**(랜덤) 원소를 제거해 반환 * 리스트는 인덱스 지정 가능



## Dictionary

`.get()`

`.pop()`





## 얕은 복사 깊은 복사

이를 참조하는 모든 변수에 영향

```python
a = [1,2,3]
copy_list = a
copy_list[0] = 5
print(a, copy_list)
# a와 copy_list 둘 다 바뀜

```

값을 복사해서 다르게 쓰고 싶다면,

```python
a = [1,2,3]
copy_list = a[:]
copy_list = list(a)
copy_list[0] = 5
print(a, copy_list)
# 이렇게 하면 a는 바뀌지 않고, copy_list만 바뀜
```

그러나 이차원 리스트인 경우는 이차원 리스트의 원소를 바꿨을 때 둘다 바뀜

따라서 이차원 리스트의 경우 `deepcopy` 이용


```python
from copy import copy
from copy import deepcopy
```



